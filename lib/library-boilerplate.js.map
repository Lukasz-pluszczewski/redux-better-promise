{"version":3,"file":"library-boilerplate.js","sources":["../src/index.js"],"sourcesContent":["import _ from 'lodash';\n\nconst defaultConfig = {\n  promiseFieldName: 'promise',\n  functionFieldName: 'function',\n  typesFieldName: 'types',\n  hooksFieldName: 'hooks',\n  typesNames: {\n    start: 'start',\n    success: 'success',\n    error: 'error',\n  },\n  hooksNames: {\n    start: 'start',\n    success: 'success',\n    error: 'error',\n  },\n};\n\nclass StartActionType {}\nclass SuccessActionType {}\nclass ErrorActionType {}\nclass FinishActionType {}\n\nexport const actionTypes = {\n  start: new StartActionType(),\n  success: new SuccessActionType(),\n  error: new ErrorActionType(),\n  finish: new FinishActionType(),\n};\n\nconst checkActionType = (actionType, type, params) => {\n  if (actionType instanceof StartActionType) {\n    return type === 'start';\n  } else if (actionType instanceof SuccessActionType) {\n    return type === 'success';\n  } else if (actionType instanceof ErrorActionType) {\n    return type === 'error';\n  } else if (actionType instanceof FinishActionType) {\n    return type === 'error' || type === 'success';\n  } else if (_.isFunction(actionType)) {\n    const { type, ...rest } = params;\n    return actionType(type, rest);\n  } else if (_.isRegExp(actionType)) {\n    return actionType.test(params.type);\n  } else if (typeof actionType === 'string') {\n    return actionType === params.type;\n  } else if (Array.isArray(actionType)) {\n    let match = false;\n    actionType.forEach(partType => {\n      if (checkActionType(partType, type, params)) {\n        match = true;\n      }\n    });\n    return match;\n  }\n};\n\nconst checkActionTypes = (actionType, actionTypeExclude, type, params) => {\n  if (actionTypeExclude) {\n    const excluded = checkActionType(actionTypeExclude, type, params);\n    if (!actionType) {\n      return !excluded;\n    }\n    if (excluded) {\n      return false;\n    }\n  }\n  return checkActionType(actionType, type, params);\n};\n\nconst createCallGlobalHooks = (hooks = []) => {\n  const hookCaller = {\n    call: (type, params) => {\n      hooks.forEach(hook => {\n        if (_.isFunction(hook)) {\n          hook(params);\n        } else if (checkActionTypes(hook.actionType, hook.actionTypeExclude, type, params)) {\n          hook.hook(params);\n        }\n      });\n    },\n    start: params => {\n      hookCaller.call('start', params);\n    },\n    success: params => {\n      hookCaller.call('success', params);\n    },\n    error: params => {\n      hookCaller.call('error', params);\n    },\n  };\n\n  return hookCaller;\n};\n\nexport default function createReduxPromiseMiddleware(additionalData, userConfig) {\n  const config = _.merge({}, defaultConfig, userConfig);\n  const callGlobalHooks = createCallGlobalHooks(config.hooks);\n\n  return ({ getState, dispatch }) => next => action => {\n    // checking if middleware can handle this kind of action\n    if (action[config.promiseFieldName] || action[config.functionFieldName]) {\n      // getting fields from action object according to config\n      const promise = action[config.promiseFieldName];\n\n      const func = action[config.functionFieldName];\n\n      const type = action.type;\n\n      let types;\n      // mapping types to standard object\n      if (action[config.typesFieldName]) {\n        if (Array.isArray(action[config.typesFieldName])) {\n          types = {\n            start: action[config.typesFieldName][0],\n            success: action[config.typesFieldName][1],\n            error: action[config.typesFieldName][2],\n          };\n        } else if (_.isPlainObject(action[config.typesFieldName])) {\n          types = {\n            start: action[config.typesFieldName][config.typesNames.start],\n            success: action[config.typesFieldName][config.typesNames.success],\n            error: action[config.typesFieldName][config.typesNames.error],\n          };\n        } else {\n          throw new Error(`${config.typesFieldName} must be an array or plain object`);\n        }\n      }\n\n      // I'm not sure if it should be an error\n      if (!type && !types) {\n        throw new Error('You must provide type or types field');\n      }\n\n      let hooks;\n      if (action[config.hooksFieldName]) {\n        if (Array.isArray(action[config.hooksFieldName])) {\n          hooks = {\n            start: action[config.hooksFieldName][0],\n            success: action[config.hooksFieldName][1],\n            error: action[config.hooksFieldName][2],\n          };\n        } else if (_.isPlainObject(action[config.hooksFieldName])) {\n          hooks = {\n            start: action[config.hooksFieldName][config.hooksNames.start],\n            success: action[config.hooksFieldName][config.hooksNames.success],\n            error: action[config.hooksFieldName][config.hooksNames.error],\n          };\n        } else {\n          throw new Error(`${config.hooksFieldName} must be an array or plain object`);\n        }\n      }\n\n      const rest = _.omit(\n        action,\n        [config.promiseFieldName, config.functionFieldName, config.typesFieldName, config.hooksFieldName, 'type']\n      );\n\n      if (types && types.start) {\n        next({ type: types.start, ...rest });\n        callGlobalHooks.start({ type: types.start, ...rest });\n      }\n      if (hooks && hooks.start) {\n        hooks.start(rest);\n      }\n\n      if (promise) {\n        if (typeof promise !== 'function') {\n          throw new Error(`${config.promiseFieldName} must be a function returning promise`);\n        }\n        if (func) {\n          if (typeof func !== 'function') {\n            throw new Error(`${config.functionFieldName} must be a function`);\n          }\n          // if we have both promise and function we call that function anyway\n          func({ getState, dispatch, ...additionalData });\n        }\n        return promise({ getState, dispatch, ...additionalData }).then(\n          result => {\n            if ((types && types.success) || type) {\n              callGlobalHooks.success({ ...rest, result, type: types ? types.success : action.type });\n            }\n            if (hooks && hooks.success) {\n              hooks.success({ ...rest, result });\n            }\n            return (types && types.success) || type\n              ? next({ ...rest, result, type: types ? types.success : action.type })\n              : null;\n          },\n          error => {\n            if (types && types.error) {\n              callGlobalHooks.error({ ...rest, error, type: types.error });\n            }\n            if (hooks && hooks.error) {\n              hooks.error({ ...rest, error });\n            }\n            return types && types.error ? next({ ...rest, error, type: types.error }) : null;\n          }\n        );\n      } else {\n        if (typeof func !== 'function') {\n          throw new Error(`${config.functionFieldName} must be a function`);\n        }\n        let result;\n        try {\n          result = func({ getState, dispatch, ...additionalData });\n          // now errors thrown in success hook and next() function will be caught as well. This is unexpected behaviour and should be changed in the future.\n          callGlobalHooks.success({ ...rest, result, type: types ? types.success : type });\n          if (hooks && hooks.success) {\n            hooks.success({ ...rest, result });\n          }\n          if ((types && types.success) || type) {\n            next({ ...rest, result, type: types ? types.success : type });\n          }\n        } catch (error) {\n          if (hooks && hooks.error) {\n            hooks.error({ ...rest, error });\n          }\n          if (types && types.error) {\n            callGlobalHooks.error({ ...rest, error, type: types.error });\n            next({ ...rest, error, type: types.error });\n          }\n        }\n      }\n    } else {\n      next(action);\n    }\n  };\n}\n"],"names":["defaultConfig","StartActionType","SuccessActionType","ErrorActionType","FinishActionType","actionTypes","checkActionType","actionType","type","params","_","isFunction","rest","isRegExp","test","Array","isArray","match","forEach","partType","checkActionTypes","actionTypeExclude","excluded","createCallGlobalHooks","hooks","hookCaller","hook","call","createReduxPromiseMiddleware","additionalData","userConfig","config","merge","callGlobalHooks","getState","dispatch","action","promiseFieldName","functionFieldName","promise","func","types","typesFieldName","isPlainObject","typesNames","start","success","error","Error","hooksFieldName","hooksNames","omit","then","result","next"],"mappings":"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"}